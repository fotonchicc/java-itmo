## [Домашнее задание 1. Hello World](./hw1_hello_world/)

1. Установите JDK 17+.
2. Скопируйте один из вариантов HelloWorld, рассмотренных на практике.
3. Откомпилируйте HelloWorld.java и получите HelloWorld.class.
4. Запустите HelloWorld и проверьте его работоспособность.
5. Создайте скрипт, компилирующий и запускающий HelloWorld из командной строки.


## [Домашнее задание 2. Сумма чисел](./hw2_sum/)

1. Разработайте класс Sum, который при запуске из командной строки будет складывать переданные в качестве аргументов целые числа и выводить их сумму на консоль.
2. Примеры запуска программы:  
`java Sum 1 2 3`  
Результат: 6  
`java Sum 1 2 -3`  
Результат: 0  
`java Sum "1 2 3"`  
Результат: 6  
`java Sum "1 2" " 3"`  
Результат: 6  
`java Sum " "`  
Результат: 0
3. Аргументы могут содержать:
   * цифры;
   * знаки + и -; 
   * произвольные пробельные символы.
4. При выполнении задания можно считать, что для представления входных данных и промежуточных результатов достаточен тип int.
5. Перед выполнением задания ознакомьтесь с документацией к классам String и Integer.
6. Для отладочного вывода используйте System.err, тогда он будет игнорироваться проверяющей программой.

**Модификация**:

* *Float*
   * Входные данные являются 32-битными числами в формате с плавающей точкой
   * Класс должен иметь имя `SumFloat`

   
## [Домашнее задание 3. Реверс](./hw3_reverse/)

1. Разработайте класс `Reverse`, читающий числа из стандартного ввода, и выводящий их на стандартный вывод в обратном порядке.
2. В каждой строке входа содержится некоторое количество целых чисел (может быть 0). Числа разделены пробелами. Каждое число помещается в тип int.
3. Порядок строк в выходе должен быть обратным по сравнению с порядком строк во входе. Порядок чисел в каждой строке так же должен быть обратным к порядку чисел во входе.
4. Вход содержит не более `10^6` чисел и строк.
5. Для чтения чисел используйте класс `Scanner`.

**Модификация**:

* *Odd*
   * Выведите (в реверсивном порядке) только нечетные числа
   * Класс должен иметь имя `ReverseOdd`



## [Домашнее задание 4. Подсчет слов](./hw4_word_stat_input/)

1. Разработайте класс `WordStatInput`, подсчитывающий статистику встречаемости слов во входном файле.
2. Словом называется непрерывная последовательность букв, апострофов (') и дефисов (Unicode category Punctuation, Dash). Для подсчета статистики слова приводятся к нижнему регистру.
3. Выходной файл должен содержать все различные слова, встречающиеся во входном файле, в порядке их появления. Для каждого слова должна быть выведена одна строка, содержащая слово и число его вхождений во входном файле.
4. Имена входного и выходного файла задаются в качестве аргументов командной строки. Кодировка файлов: UTF-8.
5. Чтение должно быть реализовано в блочном режиме с использованием `Reader`.

**Модификация**:

* *Words* 
   * В выходном файле слова должны быть упорядочены в обратном лексикографическом порядке
   * Класс должен иметь имя `WordStatWords`

   
## [Домашнее задание 5. Свой сканнер](./hw5_scanner/)

1. Реализуйте свой аналог класса Scanner на основе Reader.
2. Примените разработанный `Scanner` для решения задания «Реверс».
3. Примените разработанный `Scanner` для решения задания «Статистика слов».
4. Нужно использовать блочное чтение. Код, управляющий чтением, должен быть общим.
5. Обратите внимание на:
    - Обработку ошибок.
    - Модификаторы доступа.
    - Слова и числа, пересекающие границы блоков, особенно — больше одного раза.

**Модификация**:

* *OddOct* 
    * Выведите (в реверсивном порядке) только нечетные числа
    * Во вводе и выводе используются числа в восьмеричной системе счисления
    * Класс должен иметь имя `ReverseOddOct`

   
## [Домашнее задание 6. Статистика слов++](./hw6_wspp/)

1. Разработайте класс `Wspp`, который будет подсчитывать статистику встречаемости слов во входном файле.
2. Словом называется непрерывная последовательность букв, апострофов (') и дефисов (Unicode category Punctuation, Dash). Для подсчета статистики слова приводятся к нижнему регистру.
3. Выходной файл должен содержать все различные слова, встречающиеся во входном файле, в порядке их появления. Для каждого слова должна быть выведена одна строка, содержащая слово, число его вхождений во входной файл и номера вхождений этого слова среди всех слов во входном файле.
4. Имена входного и выходного файла задаются в качестве аргументов командной строки. Кодировка файлов: UTF-8.
5. Программа должна работать за линейное от размера входного файла время.
6. Для реализации программы используйте Collections Framework.
7. *Сложный вариант*. Реализуйте и примените класс `IntList`, компактно хранящий список целых чисел.

**Модификация**:

* *Position* 
   * Вместо номеров вхождений во всем файле надо указывать `<номер строки>:<номер в строке>`
   * Класс должен иметь имя `WsppPosition`


## [Домашнее задание 7. Разметка](./hw7_markup/markup/)

1. Разработайте набор классов для текстовой разметки.
2. Класс `Paragraph` может содержать произвольное число других элементов разметки и текстовых элементов.
3. Класс `Text` – текстовый элемент.
4. Классы разметки `Emphasis`,` Strong`, `Strikeout` – выделение, сильное выделение и зачеркивание. Элементы разметки могут содержать произвольное число других элементов разметки и текстовых элементов.
5. Все классы должны реализовывать метод `toMarkdown(StringBuilder)`, который должен генерировать Markdown-разметку по следующим правилам:
   1. текстовые элементы выводятся как есть;
   2. выделенный текст окружается символами '*'; 
   3. сильно выделенный текст окружается символами '__'; 
   4. зачеркнутый текст окружается символами '~'.
6. Следующий код должен успешно компилироваться:
   ```
    Paragraph paragraph = new Paragraph(List.of(
        new Strong(List.of(
            new Text("1"),
            new Strikeout(List.of(
                new Text("2"),
                new Emphasis(List.of(
                    new Text("3"),
                    new Text("4")
                )),
                new Text("5")
            )),
            new Text("6")
        ))
    ));
      ```
    Вызов `paragraph.toMakdown(new StringBuilder())` должен заполнять переданный StringBuilder следующим содержимым:
   `__1~2*34*5~6__`  
7. Разработанные классы должны находиться в пакете `markup`.

**Модификация**:

* *Typst* 
    * Дополнительно реализуйте метод `toTypst`, генерирующий Typst-разметку:
        - Выделенный текст заключается в `#emph[` и `]`
        - Сильно выделенный текст заключается в `#strong[` и `]`
        - Зачеркнутый текст заключается в `#strike[` и `]`


## [Домашнее задание 8. Markdown to HTML](./hw8_md2html/md2html/)

1. Разработайте конвертер из Markdown-разметки в HTML.
2. Конвертер должен поддерживать следующие возможности:
    1. Абзацы текста разделяются пустыми строками.
    2. Элементы строчной разметки: выделение (* или _), сильное выделение (** или __), зачеркивание (--), код (`)
    3. Заголовки (# * уровень заголовка)
3. Конвертер должен называться md2html.Md2Html и принимать два аргумента: название входного файла с Markdown-разметкой и название выходного файла с HTML-разметкой. Оба файла должны иметь кодировку UTF-8.
4. При выполнении этого ДЗ можно повторно использовать код ДЗ markup.
5. Конвертер может хранить исходные и сконвертированные данные в памяти, в том числе одновременно.  
6. Пример
    - Входной файл:
    ```
    # Заголовок первого уровня

    ## Второго

    ### Третьего ## уровня

    #### Четвертого
    # Все еще четвертого

    Этот абзац текста
    содержит две строки.

        # Может показаться, что это заголовок.
    Но нет, это абзац, начинающийся с `#`.

    #И это не заголовок.

    ###### Заголовки могут быть многострочными
    (и с пропуском заголовков предыдущих уровней)

    Мы все любим *выделять* текст _разными_ способами.
    **Сильное выделение**, используется гораздо реже,
    но __почему бы и нет__?
    Немного --зачеркивания-- еще никому не вредило.
    Код представляется элементом `code`.

    Обратите внимание, как экранируются специальные
    HTML-символы, такие как `<`, `>` и `&`.

    Знаете ли вы, что в Markdown, одиночные * и _
    не означают выделение?
    Они так же могут быть заэкранированы
    при помощи обратного слэша: \*.



    Лишние пустые строки должны игнорироваться.

    Любите ли вы *вложенные __выделения__* так,
    как __--люблю--__ их я?
    ```
    - Выходной файл:
    ```
    <h1>Заголовок первого уровня</h1>
    <h2>Второго</h2>
    <h3>Третьего ## уровня</h3>
    <h4>Четвертого
    # Все еще четвертого</h4>
    <p>Этот абзац текста
    содержит две строки.</p>
    <p>    # Может показаться, что это заголовок.
    Но нет, это абзац, начинающийся с <code>#</code>.</p>
    <p>#И это не заголовок.</p>
    <h6>Заголовки могут быть многострочными
    (и с пропуском заголовков предыдущих уровней)</h6>
    <p>Мы все любим <em>выделять</em> текст <em>разными</em> способами.
    <strong>Сильное выделение</strong>, используется гораздо реже,
    но <strong>почему бы и нет</strong>?
    Немного <s>зачеркивания</s> еще никому не вредило.
    Код представляется элементом <code>code</code>.</p>
    <p>Обратите внимание, как экранируются специальные
    HTML-символы, такие как <code>&lt;</code>, <code>&gt;</code> и <code>&amp;</code>.</p>
    <p>Знаете ли вы, что в Markdown, одиночные * и _
    не означают выделение?
    Они так же могут быть заэкранированы
    при помощи обратного слэша: *.</p>
    <p>Лишние пустые строки должны игнорироваться.</p>
    <p>Любите ли вы <em>вложенные <strong>выделения</strong></em> так,
    как <strong><s>люблю</s></strong> их я?</p>
    ```

**Модификация**:

* *Mark* 
   * Добавьте поддержку `~выделения цветом~`: `<mark>выделения цветом</mark>`

## [Домашнее задание 9. Чемпионат](./hw9_championship/)

1. Решите как можно больше задач Чемпионата северо-запада России по программированию 2019.
2. Материалы соревнования:
    - PCMS: Java. North-Western Russia Regional Contest - 2019
    - [Условия задач](https://nerc.itmo.ru/archive/2019/northern/nwrrc-2019-statements.pdf)
3. Задачи для решения  
**Задача : Тема	: Сложность**
* A.	Accurate Movement : Формула	: 5
* B.	Bad Treap :	Циклы : 10
* C.	Cross-Stitch	: Графы	: 40
* D.	Double Palindrome :	Массивы	: 40
* E.	Equidistant	: Деревья : 30
* H.	High Load Database	: Массивы	: 20
* I.	Ideal Pyramid	: Циклы	: 15
* J.	Just the Last Digit : Матрицы	: 20
* K.	King’s Children	: Массивы : 40
* M.	Managing Difficulties : Коллекции : 10
4. Рекомендуемое время выполнения задания: 3 часа.

## [Домашнее задание 10. Игра m,n,k](./hw10_game/game/)

1. Реализуйте игру m,n,k (k в ряд на доске m×n).
2. Добавьте обработку ошибок ввода пользователя. В случае ошибочного хода пользователь должен иметь возможность сделать другой ход.
3. Добавьте обработку ошибок игроков. В случае ошибки игрок автоматически проигрывает.
4. Доска может производить обработку хода за O(nmk).
5. Код должен находиться в пакете `game`.

**Модификация**:

* *Ромб*
   * Добавьте поддержку доски в форме ромба (квадрата, повернутого на 45°).
   * В качестве примера, сделайте доску размером 10×10.

## [Домашнее задание 11. Выражения](./hw11-14_expression/expression/)

1. Разработайте классы `Const`, `Variable`, `Add`, `Subtract`, `Multiply`, `Divide` для вычисления выражений с одной переменной в типе int (интерфейс Expression).
2. Классы должны позволять составлять выражения вида
   ```
   new Subtract(
    new Multiply(
        new Const(2),
        new Variable("x")
    ),
    new Const(3)
    ).evaluate(5)
   ```
   При вычислении такого выражения вместо каждой переменной подставляется значение, переданное в качестве параметра методу evaluate. Таким образом, результатом вычисления приведенного примера должно стать число 7.
3. Метод `toString` должен выдавать запись выражения в полноскобочной форме. Например:
   ```
   new Subtract(
    new Multiply(
        new Const(2),
        new Variable("x")
    ),
    new Const(3)
    ).toString()
   ```
   должен выдавать `((2 * x) - 3)`.
4. Реализуйте метод `equals`, проверяющий, что два выражения совпадают. Например,
    ```
    new Multiply(new Const(2), new Variable("x"))
        .equals(new Multiply(new Const(2), new Variable("x")))
    ```
            
    должно выдавать `true`, а  
    ```
    new Multiply(new Const(2), new Variable("x"))
        .equals(new Multiply(new Variable("x"), new Const(2)))
    ```
    должно выдавать false.  
5. Для тестирования программы должен быть создан класс Main, который вычисляет значение выражения `x2−2x+1`, для `x`, заданного в командной строке.
6. При выполнении задания следует обратить внимание на:
    - Выделение общего интерфейса создаваемых классов.
    - Выделение абстрактного базового класса для бинарных операций.


**Модификации**:
* *Base*
   * Реализуйте интерфейс `Expression`
* *Triple*
    * Дополнительно реализуйте поддержку выражений с тремя переменными: `x`, `y` и `z`.
    * Например, для `expr = new Subtract(new Add(new Variable("x"), new Variable("y")), new Const(1))`:
        * `expr.evaluate(2, 3, 5)` должно быть равно 4;
        * `expr.toString()` должно быть равно `((x + y) - 1)`.
    * Интерфейс/тесты `TripleExpression`.



## [Домашнее задание 12. Разбор выражений](./hw11-14_expression/expression/parser/)

1. Доработайте предыдущее домашнее задание, так что бы выражение строилось по записи вида
   `x * (x - 2)*x + 1`
2. В записи выражения могут встречаться:
    - бинарные операции: умножение *, деление /, сложение + и вычитание -;
    - унарный минус -;
    - переменные x, y и z;
    - целочисленные константы в десятичной системе счисления, помещающиеся в 32-битный знаковый целочисленный тип;
    - круглые скобки для явного обозначения приоритета операций;
    - произвольное число пробельных символов в любом месте, не влияющем на однозначность понимания формулы (например, между операцией и переменной, но не внутри констант).
3. Приоритет операторов, начиная с наивысшего
   1. унарный минус;
   2. умножение и деление;
   3. сложение и вычитание.
   
4. Разбор выражений рекомендуется производить методом рекурсивного спуска. 
    - Алгоритм должен работать за линейное время.
    - Лексический анализ (токенизация) не требуется.

**Модификации**:
* *Base*
    * Класс `ExpressionParser` должен реализовывать интерфейс `TripleParser`
    * Результат разбора должен реализовывать интерфейс `TripleExpression`
* *LastVars*
    * Имя переменной – идентификатор, последняя буква которого определяет реальную переменную (`x`, `y` или `z`).
* *Cbrt* 
    * Дополнительно реализуйте унарную операцию:  
        * `∛` – кубический корень, `∛-123` равно -4.
   

## [Домашнее задание 13. Обработка ошибок](./hw11-14_expression/expression/exceptions/)

1. Добавьте в программу, вычисляющую выражения, обработку ошибок, в том числе:
   * ошибки разбора выражений; 
   * ошибки вычисления выражений.
   
2. Для выражения `1000000*x*x*x*x*x/(x-1)` вывод программы должен иметь следующий вид:
   ```
    x       f
    0       0
    1       division by zero
    2       32000000
    3       121500000
    4       341333333
    5       overflow
    6       overflow
    7       overflow
    8       overflow
    9       overflow
    10      overflow
   ```
   Результат `division by zero (overflow)` означает, что в процессе вычисления произошло деление на ноль (переполнение).
4. При выполнении задания следует обратить внимание на дизайн и обработку исключений.
5. Человеко-читаемые сообщения об ошибках должны выводится на консоль.
6. Программа не должна «вылетать» с исключениями (как стандартными, так и добавленными).


**Модификации**:
* *Base*
   * Класс `ExpressionParser` должен реализовывать интерфейс `TripleParser`
   * Результат разбора должен реализовывать интерфейс `TripleExpression`
   * Нельзя использовать типы `long` и `double`
   * Нельзя использовать методы классов `Math` и `StrictMath`
* *LastVars* 
   * Имя переменной – идентификатор, последняя буква которого определяет реальную переменную (`x`, `y` или `z`).
* *Geom* 
   * Дополнительно реализуйте бинарные операции (минимальный приоритет):  
       * `◣` – площадь прямоугольного треугольника по двум катетам, `5 ◣ 3` равно 7;  
       * `▯` – периметр прямоугольника по двум сторонам, `4 ▯ 3` равно 14.


## [Домашнее задание 14. Вычисление в различных типах](./hw11-14_expression/expression/generic/)

Добавьте в программу разбирающую и вычисляющую выражения трех переменных поддержку вычисления в различных типах.

1. Создайте класс `expression.generic.GenericTabulator`, реализующий интерфейс `expression.generic.Tabulator`:
    ```
        public interface Tabulator {
            Object[][][] tabulate(
                String mode, String expression, 
                int x1, int x2, int y1, int y2, int z1, int z2
            ) throws Exception;
        }
    ```
    Аргументы:

    - mode — режим работы
    - **Режим** : **Тип**      
    i : int с детекцией переполнений  
    d :	double  
    bi	: BigInteger  
    - expression — вычисляемое выражение;
    - x1, x2; y1, y2; z1, z2 — диапазоны изменения переменных (включительно).

    Возвращаемое значение — таблица значений функции, где `R[i][j][k]` соответствует x = x1 + i, y = y1 + j, z = z1 + k. Если вычисление завершилось ошибкой, в соответствующей ячейке должен быть `null`.
    
2. Доработайте интерфейс командной строки:

    - Первым аргументом командной строки программа должна принимать указание на тип, в котором будут производиться вычисления:  
    **Опция : Тип**  
    -i	: int с детекцией переполнений  
    -d	: double  
    -bi	: BigInteger  
    - Вторым аргументом командной строки программа должна принимать выражение для вычисления.
    - Программа должна выводить результаты вычисления для всех целочисленных значений переменных из диапазона −2..2.
3. Реализация не должна содержать непроверяемых преобразований типов.
4. Реализация не должна использовать аннотацию @SuppressWarnings.
5. При выполнении задания следует обратить внимание на простоту добавления новых типов и операций.


**Модификации**:

* *Base* 
    * Класс `GenericTabulator` должен реализовывать интерфейс `Tabulator` и строить трехмерную таблицу значений заданного выражения.
        * `mode` – режим вычислений:
            * `i` – вычисления в `int` с проверкой на переполнение;
            * `d` – вычисления в `double` без проверки на переполнение;
            * `bi` – вычисления в `BigInteger`.
        * `expression` – выражение, для которого надо построить таблицу;
        * `x1`, `x2` – минимальное и максимальное значения переменной `x` (включительно)
        * `y1`, `y2`, `z1`, `z2` – аналогично для `y` и `z`.
        * Результат: элемент `result[i][j][k]` должен содержать значение выражения для `x = x1 + i`, `y = y1 + j`, `z = z1 + k`. Если значение не определено (например, по причине переполнения), то соответствующий элемент должен быть равен `null`.
* *Parens* 
   * Дополнительно реализуйте поддержку квадратных и фигурных скобок:  
       * `([{1 + 2} * 3] + 5)` равно 14;
       * скобки должны быть парными, `(1 + 2]` — ошибка.











